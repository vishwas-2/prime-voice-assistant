"""
Property-based tests for Voice Output Module.

This module contains property-based tests using Hypothesis to verify
the correctness properties of the Voice Output Module as specified in
the design document.
"""

import pytest
import numpy as np
from hypothesis import given, strategies as st, settings, assume
from unittest.mock import Mock, patch, MagicMock
from prime.voice import VoiceOutputModule, AudioStream
from prime.models.data_models import VoiceProfile
import time


# ============================================================================
# Hypothesis Strategies
# ============================================================================

@st.composite
def voice_profile_strategy(draw):
    """
    Generate random VoiceProfile instances for testing.
    
    Args:
        draw: Hypothesis draw function
    
    Returns:
        VoiceProfile with random but valid parameters
    """
    profile_id = draw(st.text(min_size=1, max_size=20, alphabet=st.characters(
        whitelist_categories=('Lu', 'Ll', 'Nd'), whitelist_characters='-_'
    )))
    
    voice_name = draw(st.sampled_from([
        "default", "male", "female", "david", "zira", "mark"
    ]))
    
    speech_rate = draw(st.floats(min_value=50.0, max_value=400.0))
    pitch = draw(st.floats(min_value=0.5, max_value=2.0))
    volume = draw(st.floats(min_value=0.0, max_value=1.0))
    
    return VoiceProfile(
        profile_id=profile_id,
        voice_name=voice_name,
        speech_rate=speech_rate,
        pitch=pitch,
        volume=volume
    )


@st.composite
def text_response_strategy(draw):
    """
    Generate random text responses for TTS testing.
    
    Args:
        draw: Hypothesis draw function
    
    Returns:
        Random text string suitable for TTS
    """
    # Generate sentences with 1-20 words
    num_words = draw(st.integers(min_value=1, max_value=20))
    words = [
        draw(st.text(min_size=1, max_size=10, alphabet=st.characters(
            whitelist_categories=('Lu', 'Ll')
        )))
        for _ in range(num_words)
    ]
    return " ".join(words)


@st.composite
def audio_stream_strategy(draw, min_duration_ms=100, max_duration_ms=5000):
    """
    Generate random AudioStream instances for testing.
    
    Args:
        draw: Hypothesis draw function
        min_duration_ms: Minimum duration in milliseconds
        max_duration_ms: Maximum duration in milliseconds
    
    Returns:
        AudioStream with random but valid parameters
    """
    sample_rate = draw(st.sampled_from([8000, 16000, 22050, 44100, 48000]))
    duration_ms = draw(st.floats(min_value=min_duration_ms, max_value=max_duration_ms))
    channels = draw(st.sampled_from([1, 2]))
    
    # Calculate number of samples
    num_samples = int((duration_ms / 1000.0) * sample_rate * channels)
    
    # Generate random audio data
    data = np.random.randint(-32768, 32767, size=num_samples, dtype=np.int16)
    
    return AudioStream(
        data=data,
        sample_rate=sample_rate,
        channels=channels,
        duration_ms=duration_ms
    )


# ============================================================================
# Property 6: Text-to-Speech Generation
# ============================================================================

@pytest.mark.property
class TestProperty6TextToSpeechGeneration:
    """
    **Validates: Requirements 2.1**
    
    Property 6: Text-to-Speech Generation
    For any text response generated by PRIME, the Voice_Output_Module should 
    convert it to natural speech audio.
    """
    
    @given(
        text=text_response_strategy(),
        profile=voice_profile_strategy()
    )
    @settings(max_examples=50, deadline=None)
    def test_text_converted_to_audio_stream(self, text, profile):
        """
        Property: Any text should be convertible to an AudioStream.
        
        For any valid text input, the text_to_speech method should return
        a valid AudioStream with audio data.
        """
        # Setup
        module = VoiceOutputModule(voice_profile=profile)
        
        # Execute
        audio = module.text_to_speech(text)
        
        # Verify: Returns an AudioStream
        assert isinstance(audio, AudioStream), \
            "text_to_speech should return an AudioStream"
        
        # Verify: Audio has data
        assert audio.data is not None, \
            "AudioStream should contain audio data"
        assert len(audio.data) > 0, \
            "AudioStream should have non-empty audio data"
        
        # Verify: Audio has valid properties
        assert audio.sample_rate > 0, \
            "AudioStream should have positive sample rate"
        assert audio.duration_ms > 0, \
            "AudioStream should have positive duration"
        assert audio.channels in [1, 2], \
            "AudioStream should have 1 or 2 channels"
    
    @given(text=text_response_strategy())
    @settings(max_examples=30, deadline=None)
    def test_text_to_speech_with_default_profile(self, text):
        """
        Property: Text-to-speech should work with default profile.
        
        For any text, the module should be able to generate speech using
        the default voice profile.
        """
        # Setup: Module with default profile
        module = VoiceOutputModule()
        
        # Execute
        audio = module.text_to_speech(text)
        
        # Verify: Audio generated successfully
        assert isinstance(audio, AudioStream)
        assert len(audio.data) > 0
    
    @given(profile=voice_profile_strategy())
    @settings(max_examples=30, deadline=None)
    def test_empty_text_raises_error(self, profile):
        """
        Property: Empty text should raise ValueError.
        
        For any voice profile, attempting to convert empty text should
        raise a ValueError.
        """
        module = VoiceOutputModule(voice_profile=profile)
        
        # Test empty string
        with pytest.raises(ValueError, match="Text cannot be empty"):
            module.text_to_speech("")
        
        # Test whitespace-only string
        with pytest.raises(ValueError, match="Text cannot be empty"):
            module.text_to_speech("   ")
    
    @given(
        text=text_response_strategy(),
        profile=voice_profile_strategy()
    )
    @settings(max_examples=30, deadline=None)
    def test_audio_duration_proportional_to_text_length(self, text, profile):
        """
        Property: Audio duration should be proportional to text length.
        
        For any text, longer text should produce longer audio duration.
        """
        module = VoiceOutputModule(voice_profile=profile)
        
        # Generate audio for the text
        audio = module.text_to_speech(text)
        
        # Verify: Duration is reasonable for the text length
        word_count = len(text.split())
        # Rough estimate: 100-500ms per word depending on speech rate
        min_expected_duration = word_count * 100
        max_expected_duration = word_count * 1000
        
        assert audio.duration_ms >= min_expected_duration * 0.5, \
            f"Audio too short for {word_count} words: {audio.duration_ms}ms"
        assert audio.duration_ms <= max_expected_duration * 2, \
            f"Audio too long for {word_count} words: {audio.duration_ms}ms"


# ============================================================================
# Property 7: Voice Profile Consistency
# ============================================================================

@pytest.mark.property
class TestProperty7VoiceProfileConsistency:
    """
    **Validates: Requirements 2.2**
    
    Property 7: Voice Profile Consistency
    For any session, all voice outputs should use the same voice profile 
    throughout the session.
    """
    
    @given(
        profile=voice_profile_strategy(),
        texts=st.lists(text_response_strategy(), min_size=2, max_size=10)
    )
    @settings(max_examples=50, deadline=None)
    def test_same_profile_used_for_all_outputs(self, profile, texts):
        """
        Property: All outputs in a session should use the same voice profile.
        
        For any voice profile and list of texts, all generated audio should
        use the same voice profile settings.
        """
        # Setup: Create module with specific profile
        module = VoiceOutputModule(voice_profile=profile)
        
        # Execute: Generate multiple audio outputs
        audio_outputs = []
        for text in texts:
            audio = module.text_to_speech(text)
            audio_outputs.append(audio)
        
        # Verify: All outputs exist
        assert len(audio_outputs) == len(texts)
        
        # Verify: Profile remains consistent
        current_profile = module.get_current_profile()
        assert current_profile is not None
        assert current_profile.profile_id == profile.profile_id
        assert current_profile.voice_name == profile.voice_name
        assert current_profile.speech_rate == profile.speech_rate
        assert current_profile.volume == profile.volume
    
    @given(
        initial_profile=voice_profile_strategy(),
        texts=st.lists(text_response_strategy(), min_size=2, max_size=5)
    )
    @settings(max_examples=30, deadline=None)
    def test_profile_not_changed_by_text_generation(self, initial_profile, texts):
        """
        Property: Generating speech should not modify the voice profile.
        
        For any voice profile, generating multiple speech outputs should
        not change the profile settings.
        """
        module = VoiceOutputModule(voice_profile=initial_profile)
        
        # Store initial profile values
        initial_rate = initial_profile.speech_rate
        initial_volume = initial_profile.volume
        initial_voice = initial_profile.voice_name
        
        # Generate multiple outputs
        for text in texts:
            module.text_to_speech(text)
        
        # Verify: Profile unchanged
        current = module.get_current_profile()
        assert current.speech_rate == initial_rate
        assert current.volume == initial_volume
        assert current.voice_name == initial_voice
    
    @given(
        profile=voice_profile_strategy(),
        text=text_response_strategy()
    )
    @settings(max_examples=30, deadline=None)
    def test_explicit_profile_parameter_does_not_change_current(self, profile, text):
        """
        Property: Using explicit profile parameter should not change current profile.
        
        For any voice profile, passing a different profile to text_to_speech
        should not change the module's current profile.
        """
        # Setup: Create module with one profile
        module = VoiceOutputModule(voice_profile=profile)
        original_profile = module.get_current_profile()
        
        # Create a different profile
        different_profile = VoiceProfile(
            profile_id="temp",
            voice_name="different",
            speech_rate=profile.speech_rate * 1.5,
            pitch=profile.pitch,
            volume=profile.volume
        )
        
        # Execute: Generate speech with different profile
        audio = module.text_to_speech(text, voice_profile=different_profile)
        
        # Verify: Current profile unchanged
        current = module.get_current_profile()
        assert current.profile_id == original_profile.profile_id
        assert current.speech_rate == original_profile.speech_rate


# ============================================================================
# Property 8: Voice Preference Application
# ============================================================================

@pytest.mark.property
class TestProperty8VoicePreferenceApplication:
    """
    **Validates: Requirements 2.4**
    
    Property 8: Voice Preference Application
    For any user with a configured voice preference, the Voice_Output_Module 
    should use that voice profile for all outputs.
    """
    
    @given(
        user_profile=voice_profile_strategy(),
        texts=st.lists(text_response_strategy(), min_size=1, max_size=5)
    )
    @settings(max_examples=50, deadline=None)
    def test_user_preference_applied_to_all_outputs(self, user_profile, texts):
        """
        Property: User's preferred voice profile should be used for all outputs.
        
        For any user with a configured voice preference, all generated speech
        should use that profile's settings.
        """
        # Setup: Initialize module with user's preferred profile
        module = VoiceOutputModule(voice_profile=user_profile)
        
        # Execute: Generate multiple outputs
        for text in texts:
            audio = module.text_to_speech(text)
            
            # Verify: Audio was generated (profile was applied)
            assert isinstance(audio, AudioStream)
            assert len(audio.data) > 0
        
        # Verify: Profile is still the user's preference
        current = module.get_current_profile()
        assert current.profile_id == user_profile.profile_id
        assert current.voice_name == user_profile.voice_name
        assert current.speech_rate == user_profile.speech_rate
    
    @given(
        user_profile=voice_profile_strategy(),
        text=text_response_strategy()
    )
    @settings(max_examples=30, deadline=None)
    def test_set_voice_profile_updates_preference(self, user_profile, text):
        """
        Property: Setting a new voice profile should update the preference.
        
        For any voice profile, calling set_voice_profile should update
        the module to use that profile for subsequent outputs.
        """
        # Setup: Start with default profile
        module = VoiceOutputModule()
        
        # Execute: Set user's preferred profile
        module.set_voice_profile(user_profile)
        
        # Generate speech
        audio = module.text_to_speech(text)
        
        # Verify: New profile is active
        current = module.get_current_profile()
        assert current.profile_id == user_profile.profile_id
        assert current.voice_name == user_profile.voice_name
        assert current.speech_rate == user_profile.speech_rate
        assert current.volume == user_profile.volume
    
    @given(
        profile1=voice_profile_strategy(),
        profile2=voice_profile_strategy(),
        text=text_response_strategy()
    )
    @settings(max_examples=30, deadline=None)
    def test_profile_change_affects_subsequent_outputs(self, profile1, profile2, text):
        """
        Property: Changing voice profile should affect all subsequent outputs.
        
        For any two different voice profiles, changing from one to another
        should result in subsequent outputs using the new profile.
        """
        # Ensure profiles are different
        assume(profile1.profile_id != profile2.profile_id)
        
        # Setup: Start with first profile
        module = VoiceOutputModule(voice_profile=profile1)
        
        # Verify initial profile
        assert module.get_current_profile().profile_id == profile1.profile_id
        
        # Change to second profile
        module.set_voice_profile(profile2)
        
        # Generate speech
        audio = module.text_to_speech(text)
        
        # Verify: Second profile is now active
        current = module.get_current_profile()
        assert current.profile_id == profile2.profile_id
        assert current.voice_name == profile2.voice_name
    
    @given(text=text_response_strategy())
    @settings(max_examples=20, deadline=None)
    def test_invalid_profile_raises_error(self, text):
        """
        Property: Setting invalid profile should raise ValueError.
        
        For any text, attempting to use an invalid voice profile should
        raise an appropriate error.
        """
        module = VoiceOutputModule()
        
        # Test None profile
        with pytest.raises(ValueError, match="Voice profile cannot be None"):
            module.set_voice_profile(None)
        
        # Test invalid speech rate
        invalid_profile = VoiceProfile(
            profile_id="invalid",
            voice_name="test",
            speech_rate=-10.0,  # Invalid: negative
            pitch=1.0,
            volume=0.5
        )
        with pytest.raises(ValueError, match="Speech rate must be positive"):
            module.set_voice_profile(invalid_profile)
        
        # Test invalid volume
        invalid_profile2 = VoiceProfile(
            profile_id="invalid2",
            voice_name="test",
            speech_rate=150.0,
            pitch=1.0,
            volume=1.5  # Invalid: > 1.0
        )
        with pytest.raises(ValueError, match="Volume must be between 0 and 1"):
            module.set_voice_profile(invalid_profile2)


# ============================================================================
# Additional Tests for Voice Output Module Methods
# ============================================================================

@pytest.mark.property
class TestVoiceOutputModulePlayback:
    """
    Additional property tests for audio playback functionality.
    """
    
    @given(audio=audio_stream_strategy(min_duration_ms=100, max_duration_ms=1000))
    @settings(max_examples=30, deadline=None)
    def test_play_audio_accepts_valid_stream(self, audio):
        """
        Property: Valid audio streams should be playable.
        
        For any valid AudioStream, the play_audio method should accept it
        and start playback without errors.
        """
        module = VoiceOutputModule()
        
        # Execute: Start playback
        module.play_audio(audio)
        
        # Verify: Playback started
        assert module.is_playing() is True
        
        # Cleanup: Stop playback
        module.stop_playback()
        
        # Give it a moment to stop
        time.sleep(0.1)
        
        # Verify: Playback stopped
        assert module.is_playing() is False
    
    @given(audio=audio_stream_strategy(min_duration_ms=500, max_duration_ms=2000))
    @settings(max_examples=20, deadline=None)
    def test_stop_playback_interrupts_audio(self, audio):
        """
        Property: stop_playback should interrupt ongoing playback.
        
        For any audio being played, calling stop_playback should
        interrupt the playback immediately.
        """
        module = VoiceOutputModule()
        
        # Start playback
        module.play_audio(audio)
        assert module.is_playing() is True
        
        # Stop immediately
        module.stop_playback()
        
        # Give it a moment to stop
        time.sleep(0.2)
        
        # Verify: Playback stopped
        assert module.is_playing() is False
    
    @given(
        rate=st.floats(min_value=50.0, max_value=400.0),
        profile=voice_profile_strategy()
    )
    @settings(max_examples=30, deadline=None)
    def test_adjust_speech_rate_updates_profile(self, rate, profile):
        """
        Property: Adjusting speech rate should update the current profile.
        
        For any valid speech rate, calling adjust_speech_rate should
        update the current profile's speech rate.
        """
        module = VoiceOutputModule(voice_profile=profile)
        
        # Adjust speech rate
        module.adjust_speech_rate(rate)
        
        # Verify: Profile updated
        current = module.get_current_profile()
        assert current.speech_rate == rate
    
    def test_invalid_speech_rate_raises_error(self):
        """
        Property: Invalid speech rates should raise ValueError.
        """
        module = VoiceOutputModule()
        
        # Test negative rate
        with pytest.raises(ValueError, match="Speech rate must be positive"):
            module.adjust_speech_rate(-10.0)
        
        # Test zero rate
        with pytest.raises(ValueError, match="Speech rate must be positive"):
            module.adjust_speech_rate(0.0)
    
    def test_play_invalid_audio_raises_error(self):
        """
        Property: Invalid audio streams should raise ValueError.
        """
        module = VoiceOutputModule()
        
        # Test None audio
        with pytest.raises(ValueError, match="Invalid audio stream"):
            module.play_audio(None)
        
        # Test empty audio data
        empty_audio = AudioStream(
            data=np.array([], dtype=np.int16),
            sample_rate=16000,
            channels=1,
            duration_ms=0
        )
        with pytest.raises(ValueError, match="Invalid audio stream"):
            module.play_audio(empty_audio)
