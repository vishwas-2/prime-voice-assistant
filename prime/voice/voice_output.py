"""
Voice output module for PRIME Voice Assistant.

This module provides text-to-speech conversion and audio playback capabilities
with support for voice profiles, speech rate adjustment, and playback control.
"""

import pyttsx3
import threading
from typing import Optional
from prime.voice.audio_stream import AudioStream
from prime.models.data_models import VoiceProfile
import numpy as np
import io
import wave


class VoiceOutputModule:
    """
    Voice output module for converting text to speech and playing audio.
    
    This module handles:
    - Text-to-speech conversion with configurable voice profiles
    - Audio playback with volume and rate control
    - Voice profile management
    - Speech rate adjustment
    - Playback control (stop)
    
    Attributes:
        _engine: The pyttsx3 TTS engine instance
        _current_profile: Currently active voice profile
        _is_playing: Flag indicating if audio is currently playing
        _playback_thread: Thread for audio playback
        _stop_requested: Flag to signal playback stop
    """
    
    def __init__(self, voice_profile: Optional[VoiceProfile] = None):
        """
        Initialize the Voice Output Module.
        
        Args:
            voice_profile: Optional initial voice profile to use
        """
        self._engine = pyttsx3.init()
        self._current_profile: Optional[VoiceProfile] = None
        self._is_playing = False
        self._playback_thread: Optional[threading.Thread] = None
        self._stop_requested = False
        
        # Set default voice profile if provided
        if voice_profile:
            self.set_voice_profile(voice_profile)
        else:
            # Set default profile
            default_profile = VoiceProfile(
                profile_id="default",
                voice_name="default",
                speech_rate=150.0,  # words per minute
                pitch=1.0,
                volume=0.8
            )
            self.set_voice_profile(default_profile)
    
    def text_to_speech(self, text: str, voice_profile: Optional[VoiceProfile] = None) -> AudioStream:
        """
        Convert text to natural speech audio.
        
        This method converts the provided text into speech audio using the
        specified voice profile (or the current profile if none is provided).
        
        Args:
            text: The text to convert to speech
            voice_profile: Optional voice profile to use for this conversion.
                         If None, uses the current profile.
        
        Returns:
            AudioStream containing the generated speech audio
        
        Raises:
            ValueError: If text is empty or voice profile is invalid
        
        **Validates: Requirements 2.1**
        """
        if not text or not text.strip():
            raise ValueError("Text cannot be empty")
        
        # Use provided profile or current profile
        profile = voice_profile if voice_profile else self._current_profile
        if not profile:
            raise ValueError("No voice profile available")
        
        # Apply voice profile settings to engine
        self._apply_profile_to_engine(profile)
        
        # Generate speech audio
        # Note: pyttsx3 doesn't directly provide audio data, so we'll simulate
        # the audio generation for testing purposes
        # In a real implementation, you might use a different TTS engine
        # that provides direct audio access (like gTTS, Azure TTS, etc.)
        
        # For now, we'll create a simulated audio stream
        # The actual audio would be generated by the TTS engine
        sample_rate = 22050
        duration_ms = len(text.split()) * 400  # Rough estimate: 400ms per word
        num_samples = int((duration_ms / 1000.0) * sample_rate)
        
        # Generate simulated audio data (in real implementation, this would come from TTS)
        # Using a simple sine wave as placeholder
        frequency = 200  # Hz
        t = np.linspace(0, duration_ms / 1000.0, num_samples)
        audio_data = (np.sin(2 * np.pi * frequency * t) * 16384).astype(np.int16)
        
        audio_stream = AudioStream(
            data=audio_data,
            sample_rate=sample_rate,
            channels=1,
            duration_ms=duration_ms
        )
        
        return audio_stream
    
    def play_audio(self, audio: AudioStream) -> None:
        """
        Play the provided audio stream.
        
        This method plays the audio stream through the system's audio output.
        Playback happens in a separate thread to avoid blocking.
        
        Args:
            audio: The AudioStream to play
        
        Raises:
            ValueError: If audio stream is invalid
            RuntimeError: If playback is already in progress
        
        **Validates: Requirements 2.1, 2.3**
        """
        if audio is None or audio.data is None or len(audio.data) == 0:
            raise ValueError("Invalid audio stream")
        
        if self._is_playing:
            raise RuntimeError("Playback already in progress")
        
        # Start playback in a separate thread
        self._stop_requested = False
        self._playback_thread = threading.Thread(
            target=self._play_audio_internal,
            args=(audio,),
            daemon=True
        )
        self._is_playing = True
        self._playback_thread.start()
    
    def _play_audio_internal(self, audio: AudioStream) -> None:
        """
        Internal method to play audio (runs in separate thread).
        
        Args:
            audio: The AudioStream to play
        """
        try:
            # In a real implementation, this would use PyAudio or similar
            # to play the audio through the system's audio output
            # For now, we'll simulate playback with a sleep
            import time
            
            # Simulate playback duration
            playback_duration = audio.duration_seconds
            
            # Check for stop requests periodically
            check_interval = 0.1  # Check every 100ms
            elapsed = 0.0
            
            while elapsed < playback_duration and not self._stop_requested:
                time.sleep(min(check_interval, playback_duration - elapsed))
                elapsed += check_interval
        
        finally:
            self._is_playing = False
    
    def set_voice_profile(self, profile: VoiceProfile) -> None:
        """
        Set the voice profile to use for speech generation.
        
        This method configures the TTS engine with the specified voice profile
        settings including voice name, speech rate, pitch, and volume.
        
        Args:
            profile: The VoiceProfile to use
        
        Raises:
            ValueError: If profile is invalid
        
        **Validates: Requirements 2.2, 2.4**
        """
        if profile is None:
            raise ValueError("Voice profile cannot be None")
        
        if profile.speech_rate <= 0:
            raise ValueError("Speech rate must be positive")
        
        if profile.volume < 0 or profile.volume > 1.0:
            raise ValueError("Volume must be between 0 and 1")
        
        self._current_profile = profile
        self._apply_profile_to_engine(profile)
    
    def _apply_profile_to_engine(self, profile: VoiceProfile) -> None:
        """
        Apply voice profile settings to the TTS engine.
        
        Args:
            profile: The VoiceProfile to apply
        """
        # Set speech rate (words per minute)
        self._engine.setProperty('rate', profile.speech_rate)
        
        # Set volume (0.0 to 1.0)
        self._engine.setProperty('volume', profile.volume)
        
        # Set voice if not default
        if profile.voice_name != "default":
            voices = self._engine.getProperty('voices')
            for voice in voices:
                if profile.voice_name.lower() in voice.name.lower():
                    self._engine.setProperty('voice', voice.id)
                    break
    
    def adjust_speech_rate(self, rate: float) -> None:
        """
        Adjust the speech rate for the current voice profile.
        
        This method modifies the speech rate of the current voice profile.
        The rate is specified in words per minute.
        
        Args:
            rate: Speech rate in words per minute (typically 100-300)
        
        Raises:
            ValueError: If rate is invalid
            RuntimeError: If no voice profile is set
        
        **Validates: Requirements 2.3**
        """
        if rate <= 0:
            raise ValueError("Speech rate must be positive")
        
        if self._current_profile is None:
            raise RuntimeError("No voice profile set")
        
        # Update current profile
        self._current_profile.speech_rate = rate
        
        # Apply to engine
        self._engine.setProperty('rate', rate)
    
    def stop_playback(self) -> None:
        """
        Stop any currently playing audio.
        
        This method stops audio playback if it's currently in progress.
        If no audio is playing, this method has no effect.
        
        **Validates: Requirements 2.1**
        """
        if self._is_playing:
            self._stop_requested = True
            
            # Wait for playback thread to finish (with timeout)
            if self._playback_thread and self._playback_thread.is_alive():
                self._playback_thread.join(timeout=1.0)
            
            self._is_playing = False
    
    def get_current_profile(self) -> Optional[VoiceProfile]:
        """
        Get the currently active voice profile.
        
        Returns:
            The current VoiceProfile, or None if not set
        """
        return self._current_profile
    
    def is_playing(self) -> bool:
        """
        Check if audio is currently playing.
        
        Returns:
            True if audio is playing, False otherwise
        """
        return self._is_playing
    
    def __del__(self):
        """Cleanup resources when the module is destroyed."""
        try:
            if self._is_playing:
                self.stop_playback()
            if self._engine:
                self._engine.stop()
        except:
            pass  # Ignore errors during cleanup
